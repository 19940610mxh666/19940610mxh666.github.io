<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringIoC]]></title>
    <url>%2F2019%2F03%2F20%2FSpringIoC%2F</url>
    <content type="text"><![CDATA[#SpringIoC #初识IoCInversion of Control,控制反转。为什么需要IoC?IoC的具体意义是什么？它到底有什么独到之处？技术为业务服务，还是从实际的业务角度来理解吧。例如在一个FX（Foreign Exchange）项目中，通常情况下，都是先从不同的新闻社订阅新闻来源，然后通过批处理程序定时地到指定的新闻服务器抓取最新的外汇新闻，接着讲这些新闻存入本地数据库，最后在FX系统的前台界面显示。假设有一个FXNewsProvider类来做以上工作，代码如下：123456789101112131415public class FXNewsProvider&#123; private IFXNewsListener newsListener; private IFXNewsPersister newsPersistener; public void getAndPersistNews()&#123; String[] newsIds=newsListener.getAvailableNewsIds(); if(ArrayUtils.isEmpty(newsIds))&#123; return; &#125; for(String newsId:newsIds)&#123; FXNewsBean newsBean=newsListener.getNewsByPK(newsId); newPersistener.persistNews(newsBean); newsListener.postProcessIfNeccessary(newsId); &#125; &#125;&#125; 其中，FXNewsProvider需要依赖IFXNewsListener来帮助抓取新闻内容，并依赖IFXNewsPersister存储抓取的新闻。假设默认使用某社的新闻，那么我们相应地提供了ThisNewsListener和ThisNewsPersister两个实现。通常情况下，需要在构造函数中构造IFXNewsProvider依赖的这两个类（以下将这种被其他类依赖的类或对象，简称为“依赖类”、“依赖对象”），如代码下1234public FXNewsProvider()&#123; newsListener=new ThisNewsListener(); newsPersistener=new ThisNewsPersistener();&#125; 看，这就是我们通常的做事方式！如果我们依赖于某个类或服务，最简单而有效的方式就是直接在类的构造函数中新建相应的依赖类。这就好比要造房子，需要用家具，这个时候，根据通常解决对象依赖关系的做法，我们就是直接打造出需要的家具来。不过，通常都是分工明确的，所以，大多数情况下，我们可以直接去家具广场将家具买回来，然后根据需要装修。不管是直接打造家具（通过new构造依赖对象），还是去家具广场买家具（或许是通过ServiceLocator（J2EE核心模式之一，主要是通过引入中间代理者消除对象间复杂的耦合关系，并同意管理分散的复杂的耦合关系）解决直接的耦合），有一个共同点需要我们关注，那就是，我们都是自己主动地去获取依赖对象。可是回头想想，我们自己每次用到什么依赖对象都要主动地去获取，这是否真的必要？我们最终所要做的，其实就是直接调用依赖对象所提供的某项服务而已。只要用到这个依赖对象的时候，它能够准备就绪，我们完全可以不管这个对象是自己找来的还是别人送过来的。对于FXNewsProvider来说，那就是在getAndPersisNews（）方法调用newsListener的相应方法时，newsListener能够准备就绪就可以了。如果有人能够在我们需要时将某个依赖对象送过来，为什么还要大费周折地自己去折腾呢？实际上，IoC就是为了帮助我们避免之前的“大费周折”，而提供了更加轻松简单的方式。它的方砖，就反转在让你从原来的事必躬亲，转变为现在的享受服务。你想啊，原来还得鞍马劳顿，什么东西都得自己去拿，现在是用什么，让别人直接送过来就成。所以，简单点儿说，IoC的理念就是，让别人为你服务！在下图中，也就是让IoC Service Provider来为你服务！通常情况下，被注入对象会直接依赖于被依赖对象。但是，在IoC的场景中，二者之间通过IoC Service Provider来打交道，所有的被注入对象和依赖对象现在由IoC Service Provider统一管理。被注入对象需要什么，直接跟IoC Service Provider招呼一声，然后就会把相应的被依赖对象注入到被注入对象，从而达到IoC Service Provider为被注入对象服务的目的。IoC Service Provider在这里就是通常的IoC容器所充当的角色。从被注入对象的角度看，与之前直接寻求依赖对象相比，依赖对象的取得方式发生了反转，控制也从被注入对象转到了IoC Service Provider那里。 ##依赖倒置原则Dependency Inversion Principle假设设计一辆汽车：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计车身，最后根据车身设计好整个汽车。这里就出现了一个“依赖”关系：汽车依赖车身，车身依赖底盘，底盘依赖轮子。这样的设计看起来没问题，但是可维护性却很低。假设设计完工之后，上司却突然说根据市场需求的变动，要我们把车子的轮子设计都改大一码。这下我们就蛋疼了：因为我们是根据轮子的尺寸设计的底盘，轮子的尺寸一改，底盘的设计就得修改；同样因为我们是根据底盘设计的车身，那么车身也得改，同理汽车设计也得改–整个设计几乎都得改！]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github]]></title>
    <url>%2F2019%2F03%2F19%2Fgithub%2F</url>
    <content type="text"><![CDATA[测试]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC流程分析和源码分析]]></title>
    <url>%2F2018%2F09%2F20%2FSpringMVC%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[SpringMVC的执行流程https://blog.csdn.net/lang_programmer/article/details/71598042 工作流程图 工作流程 服务器接受请求，被DispatcherServlet捕获； DispatcherServlet对请求URL解析，得到请求资源标识符（URI）。然后根据URI，调用HandlerMapping获得该Handler配置的所有相关对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExcutionChain对象的形式返回； DispatcherServlet根据获得的Handler，选择一个合适的HandlerAdapter（如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）； 提取request中的模型数据，填充Handler入参，开始执行Handler（Controller）。在填充Handler的入参过程中，根据你的配置，Spring将会做一些额外的工作； HttpMessageConveter：将请求消息（如Json，xml等数据）转换成一个对象，将对象转换为指定的响应信息 数据转换：对请求消息进行数据转换，如String转换成Integer，Double等 数据格式化：对请求小时进行数据格式化。如将字符串转船成格式化数据或格式化日期 数据验证：验证数据的有效性（长度，格式等）。验证结果存储到BindingResult或Error中 Handler执行完成之后，向DispatcherServlet返回一个ModelAndView对象 根据返回的ModelAndView，选择一个合适的ViewResolver（必须是已经注册到Spring容器中的ViewResolver）返回给DispatcherServlet； ViewResolver结合Model和View，渲染视图； 将渲染结果返回给客户端；一些特点 采用了前端控制模式（DispatcherServlet） Spring为什么要结合使用HandlerMapping以及HandlerAdapter来处理Handler? 符合面向对象中的单一职责原则，代码架构清晰，便于维护，最重要的是代码可复用性高。如HandlerAdapter可能会被用于处理多种Handler。源码解析处理过程分析 tomcat启动时，都会加载web.xml文件，所以我们从web.xml入手。 12345678910111213141516&lt;servlet &gt; &lt;servlet-name &gt;spring-mvc&lt;/servlet-name&gt; &lt;!-- servlet类 --&gt; &lt;servlet-class &gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 初始化参数 --&gt; &lt;init-param &gt; &lt;param-name &gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value &gt;classpath:/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动时加载 --&gt; &lt;load-on-startup &gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping &gt; &lt;servlet-name &gt;spring-mvc&lt;/servlet-name&gt; &lt;url-pattern &gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 在这个配置文件中，可以看到DispatcherServlet、contextConfigLocation和spring-mvc.xml。在启动时，加载初始化参数contextConfigLocation，即spring-mvc.xml。 来看看DispatcherServlet的结构很显然是Servlet的子类，关注它的service、doGet和doPost等方法。在父类FrameServlet，我们找到了service方法。 12345678910111213141516/** * Override the parent class implementation in order to intercept PATCH * requests. */ @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String method = request.getMethod(); if (method.equalsIgnoreCase(RequestMethod.PATCH.name())) &#123; processRequest(request, response); &#125; else &#123; super.service(request, response); &#125; &#125; 根据service方法，我们一步步找到一个方法链service-&gt;processRequest-&gt;doService-&gt;doDispatcher，我们最终将目光定位在doDispatch，因为从它的方法体可以看出它是整个SpringMVC的核心方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; //处理文件上传请求 processedRequest = checkMultipart(request); multipartRequestParsed = processedRequest != request; // 解析请求，获取HandlerExecutionChain对象 mappedHandler = getHandler(processedRequest); if (mappedHandler == null || mappedHandler.getHandler() == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // 从HandlerExecutionChain对象获取HandlerAdapter对象，实际上是从HandlerMapping对象中获取 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified); &#125; if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; //在controller方法执行前，执行拦截器的相关方法（pre） if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; try &#123; // 执行HandlerAdapter对象的handler方法，返回ModelAndView mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; &#125; applyDefaultViewName(request, mv); //在controller方法执行后，执行拦截器的相关方法（post） mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; //进行视图解析 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Error err) &#123; triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); return; &#125; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125; 包含了解析请求，执行相关拦截器，执行handle方法，执行视图解析器方法. 至于HandlerAdapter是干嘛的？它的handler方法有什么用？我们毫无概念，接下来换个调度切入，所以我选择Controller，得先从配置文件入手，因为它采用了Spring的IoC。 12345678910111213141516bean id=&quot;controller&quot; class=&quot;com.mvc.controller.MyController&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;interceptor&quot; class=&quot;com.mvc.interceptor.MyInterceptor&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;urlMapping&quot; class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt; &lt;property name=&quot;mappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;controller&quot;&gt;controller&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=&quot;interceptors&quot;&gt; &lt;array&gt; &lt;ref bean=&quot;interceptor&quot;&gt;&lt;/ref&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 配置文件又给了我们一条重要信息：controller和拦截器都是作为SimpleURLHandlerMapping的参数穿进去的，而SimpleURLHandlerMapping是HandlerMapping的子类。从这里就可以猜测，controller的核心方法要么被HandlerMapping直接调用，要么被HandlerMapping的附属产品（类）进行调用，接下来我们来查看controller核心方法的调用情况。很幸运，看到SimpleControllerHandlerAdapter和DispatcherServlet.doDispatch（request,response）。HandlerAdapter类和doDispatch(request, response)方法完美地结合在了一起。再看SimpleControllerHandlerAdapter的handler方法：123456@Override public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return ((Controller) handler).handleRequest(request, response); &#125; 这里也有一个方法的调用链，从上图就可以看出，handle方法最终是调用handleRequestInternal方法，也就是我们在controller中自定义的方法。总而燕子，HandlerAdapter的Handler方法是用来调用controller中的handleRequestInternal方法的，而handleRequestInternal的方法体正是我们自定义的业务逻辑。 总结流程： 当request到来时，DispatcherServlet对request进行捕获，并执行doService方法，继而执行doDispatch方法。 HandlerMapping解析请求，并且返回HandlerExecutionChain（其中包含controllers和interceptors），然后通过HandlerExecutionChain得到Handler相关类，根据Handler获取执行它的HandlerAdapter类。 先执行拦截器的pre相关方法，接着执行handler方法，它会调用controller的handleRequestInternal方法（方法体由用户自定义），最后调用拦截器的post相关方法。 解析handler方法返回的ModelAndView（可以在配置文件中配置ResourceViewResolver，也就是视图解析器），渲染页面并response给客户端。]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中单例与线程安全]]></title>
    <url>%2F2018%2F09%2F20%2FSpring%E4%B8%AD%E5%8D%95%E4%BE%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Spring单例与线程安全本文来源https://www.cnblogs.com/dolphin0520/p/3920407.html 单例模式Spring中的bean，默认使用单例模式。在多线程开发的时候需要注意。那么单例模式下是如何保证线程安全的呢？答案就是使用了ThreadLoacl。需要明白的是虽然Spring bean是单例的，但是其中的方法对每个线程来说都是独立运行的，不存在多线程问题，只有成员变量有多线程问题，所以方法里面如果有用到成员变量就要考虑用安全的数据结构。 ThreadLocalThreadLocal是什么ThreadLocal也被叫做线程本地变量，或者线程本地存储。它为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。先来看看代码123456789101112131415class ConnectionMannger&#123; private static Connection connect=null; public static Connection openConnection()&#123; if(connect==null)&#123; connect=DriverMannger.getConnection(); &#125; return connect; &#125; public static void closeConnection()&#123; if(connect!=null)&#123; connect.close(); &#125; &#125;&#125; 现在有一个JDBC的管理类，这段代码在单线程中使用是没有问题的。但是如果多线程中就有问题了。在多线程中会有线程安全问题：第一，这里面的2个方法都没有进行同步，很可能在openConnection方法中会多次创建connect；第二，由于connect是静态变量，那么必然在调用connect的地方需要使用到同步来保障线程安全，因为很可能一个线程在使用connect进行数据库操作，而另一个线程调用closeConnection关闭连接。所以出于线程安全的考虑，必须将这段代码的两个方法进行同步处理，并且在调用connect的地方需要进行同步处理。这样将会大大影响程序的执行效率，因为一个线程在使用connect进行数据库操作的时候，其它线程只能等待。那么这个地方到底需不需要将connect遍历进行共享？事实上，是不需要的。假如每个线程中都有一个connect变量，各个线程之间对connect变量的访问实际上是没有依赖关系的，即一个线程不需要关系其它线程是否对这一个connect进行了修改。那么既然不要在线程间共享这个变量，可以直接这样处理，在每个需要使用使用这个方法的时候才创建数据库连接，然后在方法调用结束后释放这个连接。比如下面这样1234567891011121314151617181920212223242526class ConnectionManager &#123; private Connection connect = null; public Connection openConnection() &#123; if(connect == null)&#123; connect = DriverManager.getConnection(); &#125; return connect; &#125; public void closeConnection() &#123; if(connect!=null) connect.close(); &#125;&#125; class Dao&#123; public void insert() &#123; ConnectionManager connectionManager = new ConnectionManager(); Connection connection = connectionManager.openConnection(); //使用connection进行操作 connectionManager.closeConnection(); &#125;&#125; 这样处理确实没有问题，由于每次都是在方法区内部创建的连接，那么线程之间自然不存在线程安全问题。但是这样会有一个致命的影响：导致服务器压力非常大，并且严重影响程序执行性能。由于在方法中需要频繁地开启和关闭数据库连接，这样不仅严重影响程序执行效率，还可能导致服务器压力巨大。那么在这种情况下使用ThreadLocal是非常适合的。因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，就不存在线程安全问题了，也不会影响程序执行效率。但是需要注意，虽然ThreadLocal能够解决上面说的问题，但是由于在每个线程中都创建了副本，所以要考虑它对资源的消耗，比如内存的占用回避不适用ThreadLocal要大。 深入ThreadLocal那么ThreadLocal是如何实现的呢？先来看看ThreadLocal提供的几个方法：public T get() { } public void set(T value) { } public void remove() { } protected T initialValue() { }get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()方法用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来使用时进行重写的，它是一个延迟加载方法，下面会详细说明。首先来看看ThreadLocal类是如何为每个线程创建一个变量的副本的。get方法：123456789101112131415161718192021222324 /** * Returns the value in the current thread&apos;s copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread&apos;s value of this thread-local */ public T get() &#123;//获取当前线程 Thread t = Thread.currentThread();//获得一个ThreadLocalMap类型的map ThreadLocalMap map = getMap(t); if (map != null) &#123; //传入this ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; 来仔细分析一下，先看看getMap()方法做了什么12345678910/** * Get the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @return the map */ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; 在这个方法中，是调用当前线程t，返回当前线程t中的一个成员变量threadLocals。那么成员变量threadLocals是什么：123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 实际上是一个ThreadLLocalMap，这个类型是ThreadLocal类的一个内部类，继续看ThreadLocalMap的实现：12345678910111213141516171819static class ThreadLocalMap &#123; /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as &quot;stale entries&quot; in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; 可以看到ThreadLocalMap的Entry集成了WeakReference，并且使用ThreadLocal作为键值。然后再继续看setInitialValue()方法的实现：12345678910111213141516/** * Variant of set() to establish initialValue. Used instead * of set() in case user has overridden the set() method. * * @return the initial value */private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 显然，就是如果map不为空，就设置键值对为空，再创建Map，看一下createMap的实现：12345678910/** * Create the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @param firstValue value for the initial entry of the map */void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 至此，ThreadLocal是如何为每个线程创建变量的副本的过程就出来了。首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。初始化时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的变量副本为value，存到threadLocals。然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。下面通过一个例子来证明通过ThreadLocal能达到在每个线程中创建变量副本的效果：123456789101112131415161718192021222324252627282930313233343536373839package com.mxh.dataStructure.array;/** * @author mxh * @version 创建时间：2018年8月15日下午11:12:58 类说明 */public class Test &#123; ThreadLocal&lt;Long&gt; longLocal=new ThreadLocal&lt;Long&gt;(); ThreadLocal&lt;String&gt; stringLocal=new ThreadLocal&lt;String&gt;(); public void set()&#123; longLocal.set(Thread.currentThread().getId()); stringLocal.set(Thread.currentThread().getName()); &#125; public long getLong()&#123; return longLocal.get(); &#125; public String getString()&#123; return stringLocal.get(); &#125; public static void main(String[] args) throws InterruptedException &#123; final Test test=new Test(); test.set(); System.out.println(test.getLong()); System.out.println(test.getString()); Thread t1=new Thread()&#123; public void run()&#123; test.set(); System.out.println(test.getLong()); System.out.println(test.getString()); &#125; &#125;; t1.start(); t1.join(); System.out.println(test.getLong()); System.out.println(test.getString()); &#125;&#125; 输出结果为从这段代码的输出结果可以看出，在main线程中和t1线程中，longLocal保存的副本值和stringLocal保存的副本值都不一样。最后一次输出副本是为了证明在main线程中和t1线程中的副本值确实不一样。总结： 实际的用过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的； 为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可以有多个threadLocal变量，就像上面代码中的longLocal和stringLocal； 在进行get之前，必须先set，否则报空指针异常；如果想要在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。因为在上面的代码分析过程中，如果没有先set，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回，而在setInitialValue方法中，有一个语句是T value=initialValue()，而在默认情况下，initialValue方法返回的是null。看下面这个例子123456789101112131415161718192021222324252627282930313233343536373839package com.mxh.dataStructure.array;public class Test &#123; ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;(); ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;(); public void set() &#123; longLocal.set(Thread.currentThread().getId()); stringLocal.set(Thread.currentThread().getName()); &#125; public long getLong() &#123; return longLocal.get(); &#125; public String getString() &#123; return stringLocal.get(); &#125; public static void main(String[] args) throws InterruptedException &#123; final Test test = new Test(); System.out.println(test.getLong()); System.out.println(test.getString()); Thread thread1 = new Thread()&#123; public void run() &#123; test.set(); System.out.println(test.getLong()); System.out.println(test.getString()); &#125;; &#125;; thread1.start(); thread1.join(); System.out.println(test.getLong()); System.out.println(test.getString()); &#125;&#125; 在main线程中，没有先set，直接get，运行时报空指针异常。但是如果改成下面这段代码，重写initialValue()方法；1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.mxh.dataStructure.array;public class Test &#123; ThreadLocal&lt;Long&gt; longLocal = new ThreadLocal&lt;Long&gt;()&#123; protected Long initialValue() &#123; return Thread.currentThread().getId(); &#125;; &#125;; ThreadLocal&lt;String&gt; stringLocal = new ThreadLocal&lt;String&gt;()&#123;; protected String initialValue() &#123; return Thread.currentThread().getName(); &#125;; &#125;; public void set() &#123; longLocal.set(Thread.currentThread().getId()); stringLocal.set(Thread.currentThread().getName()); &#125; public long getLong() &#123; return longLocal.get(); &#125; public String getString() &#123; return stringLocal.get(); &#125; public static void main(String[] args) throws InterruptedException &#123; final Test test = new Test(); test.set(); System.out.println(test.getLong()); System.out.println(test.getString()); Thread thread1 = new Thread()&#123; public void run() &#123; test.set(); System.out.println(test.getLong()); System.out.println(test.getString()); &#125;; &#125;; thread1.start(); thread1.join(); System.out.println(test.getLong()); System.out.println(test.getString()); &#125;&#125; 就可以不用set而直接调用get了。 ThreadLocal的应用场景最常见的ThreadLocal使用场景是用来解决数据库连接、session管理等等。如：12345678910private static ThreadLocal&lt;Connection&gt; connectionHolder= new ThreadLocal&lt;Connection&gt;() &#123;public Connection initialValue() &#123; return DriverManager.getConnection(DB_URL);&#125;&#125;; public static Connection getConnection() &#123;return connectionHolder.get();&#125; 或者（来自http://www.iteye.com/topic/103804）1234567891011121314private static final ThreadLocal threadSession = new ThreadLocal(); public static Session getSession() throws InfrastructureException &#123; Session s = (Session) threadSession.get(); try &#123; if (s == null) &#123; s = getSessionFactory().openSession(); threadSession.set(s); &#125; &#125; catch (HibernateException ex) &#123; throw new InfrastructureException(ex); &#125; return s;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql中的sql优化]]></title>
    <url>%2F2018%2F09%2F19%2Fmysql%E4%B8%AD%E7%9A%84sql%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据库优化一、一些常见的SQL实践（1）负向条件查询不能使用索引 * select * from order where status!=0 and stauts!=1 not int exists都不是好习惯 可以优化为in查询： * select * from order where status in(2,3) （2）前导模糊查询不能使用索引 * select * from order where desc like &apos;%XX&apos; 而非前导模糊查询则可以： * select * from order where desc like &apos;XX%&apos; （3）数据区分度不大的字段不宜使用索引 * select * from user where sex=1 原因：性别只有男，女，每次过滤掉的数据很少，不宜使用索引。 经验上，能过滤80%数据时就可以使用索引。对于订单状态，如果状态值很少，不宜使用索引，如果状态值很多，能够过滤大量数据，则应该建立索引。 （4）在属性上进行计算不能命中索引 * select * from order where YEAR(date) &lt; = &apos;2017&apos; 即使date上建立了索引，也会全表扫描，可优化为值计算： * select * from order where date &lt; = CURDATE() 或者： * select * from order where date &lt; = &apos;2017-01-01&apos; 二、并非周知的SQL实践（5）如果业务大部分是单条查询，使用Hash索引性能更好，例如用户中心 * select * from user where uid=? * select * from user where login_name=? 原因：B-Tree索引的时间复杂度是O(log(n))Hash索引的时间复杂度是O(1) （6）允许为null的列，查询有潜在大坑单列索引不存null值，复合索引不存全为null的值，如果列允许为null，可能会得到“不符合预期”的结果集 * select * from user where name != &apos;shenjian&apos; 如果name允许为null，索引不存储null值，结果集中不会包含这些记录。 所以，请使用not null约束以及默认值。 （7）复合索引最左前缀，并不是值SQL语句的where顺序要和复合索引一致用户中心建立了(login_name, passwd)的复合索引 * select * from user where login_name=? and passwd=? * select * from user where passwd=? and login_name=? 都能够命中索引 * select * from user where login_name=? 也能命中索引，满足复合索引最左前缀 * select * from user where passwd=? 不能命中索引，不满足复合索引最左前缀 （8）使用ENUM而不是字符串ENUM保存的是TINYINT，别在枚举中搞一些“中国”“北京”“技术部”这样的字符串，字符串空间又大，效率又低。]]></content>
      <categories>
        <category>sql优化</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码]]></title>
    <url>%2F2018%2F09%2F18%2F%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[字符编码：ASCII,Unicode和UTF-8主要参考了阮一峰大佬的博客 ASCII在计算机内部，所有信息最终都将被转换成一个二进制值。每一位二进制（bit）有0和1两种状态，因此八位二进制就可以组合出256中状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256中不同的状态，每一个状态对应一个符号，就是256个符号，从00000000到11111111。上世纪60年代，美国制定了一套字符编码，对英语字符与二进制之间的关系，做了统一的规定。这被称为ASCII码，一直沿用至今。ASCII一共规定了128个字符的编码，比如空格space是32（二进制00100000），大写的字符A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面一位统一规定为0。 非ASCII码英语用128个符号编码就够了，但是用来表示其它语言，128个符号是不够的。比如在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，在法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel（ג），在俄语编码中又会代表另一个符号。但是不管怎么样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128-255这一段。至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256*256=65536个符号。中文编码的问题需要专文套路，这里不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的Unicode和UTF-8是毫无关系的。 Unicode正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，想要打开一个文本文件，就必须知道他的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字表示的，这是一种所有符号的编码。Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639便是阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org。 Unicode的问题需要注意的是，Unicode知识一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。比如，汉字严的Unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要两个字节。表示其它更大的符号，可能需要3个字节或者4个字节，甚至更多。这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或者四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此打出三倍，这是无法接受的。它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说许多种不同的二进制格式，可以用来表示Unicode。2）Unicode在很长一段时间内无法推广，直到互联网的出现。 UTF-8互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是互联网上使用最广的一个Unicode的实现方式。其它实现方式还包括UTF-16（字符用两个字节或者四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。UTF-8的编码规则很简单，只有两条：1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的Unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。2）对于n字节的符号(n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的Unicode码。下表总结了编码规则，字母 x表示可用编码的位。 Unicod符号范围 （十六进制） | UTF-8编码方式（二进制） ------------------------------------------------------------ 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 根据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。下面，还是以汉字严为例，演示如实实现UTF-8编码。严的Unicod是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此严的UTF-8编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的UTF-8的编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。 Unicode与UTF-8之间的转换通过上一节的例子，可以看到严的Unicode码是4E25，UTF-8编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现。 Little endian和Big endian以汉字严为例，Unicode码是4E25，需要两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，这就是big endian方式；25在前，4E在后，这是little endian方式。第一个字节在前，就是”大头方式”（Big endian），第二个字节在前就是”小头方式”（Little endian）。那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。 JAVA中的编码问题Java中采用Unicode编码。]]></content>
      <categories>
        <category>编码</category>
        <category>编码格式</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F08%2F11%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat]]></title>
    <url>%2F2018%2F08%2F11%2Ftomcat%2F</url>
    <content type="text"></content>
      <categories>
        <category>服务器</category>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>轻量级</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具类]]></title>
    <url>%2F2018%2F08%2F09%2FUntitled%2F</url>
    <content type="text"><![CDATA[自己的项目]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>java utils</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis]]></title>
    <url>%2F2018%2F08%2F08%2FMybatis%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring]]></title>
    <url>%2F2018%2F08%2F08%2FSpring%2F</url>
    <content type="text"><![CDATA[开坑]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构（一）]]></title>
    <url>%2F2018%2F08%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构（一）主要是对Java中常用的数据结构做分析。 Java中的数据结构在Java中，数据结构主要分为Collection和Map两个接口。 java.util.Collection [I] +–java.util.List [I] +–java.util.LinkedList [C] +–java.util.ArrayList [C] +–java.util.Vector [C] +–java.util.Stack [C] +–java.util.Set [I] +–java.util.HashSet [C] +–java.util.SortedSet [I] +–java.util.TreeSet [C] java.util.Queue [I] +–java.util.Deque [I] +–java.util.PriorityQueue [C] java.util.Map [I] +–java.util.SortedMap [I] +–java.util.TreeMap [C] +–java.util.HashTable [C] +–java.util.HashMap [C] +–java.util.LinkedHashMap [C] +–java.util.weakHashMap [C] [I]:接口[C]:类 CollectionCollection中继承了Iterable接口。Iterable:凡是继承了这个接口的集合，都支持迭代。提供了迭代器和foreachIterator:迭代器。在这里出现了迭代器。迭代器是Java集合中非常重要的一个“工具”。主要功能是遍历集合。下面先来说说Iterable123456789101112131415public interface Iterable&lt;T&gt; &#123; //提供了一个迭代器 Iterator&lt;T&gt; iterator(); //实现了遍历 default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; //可分割迭代器 default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; 在Iterable中可以看出，这个接口提供了一个迭代器和一个可分割迭代器。在这里先不讨论Spliterator，这个涉及了并行。或许有人会对接口中为什么能实现方法感到疑惑。这里告诉大家。这是在Java8中新增的特性。接口也可以定义方法（default method）。这样可以大大地提升效率。在foreach()中，有个Consumer类型的参数。这里同样是Java8的新增特性之一，代表一个操作。这个操作接受单一输入参数并且不返回任何结果。期望在操作内部实现功能。具体内容请看Java8新特性。这里只需要知道Iterable提供了迭代器并且实现了遍历方法即可。Iterator:迭代器。不同的集合，内部结构不同。那么如果能提供一个简单，通用的遍历元素的方式，对于开发效率的提升和学习都是有很大帮助的。因此，引入了迭代器。迭代器不暴露集合的内部结构，对元素进行操作。来看看迭代器的源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public interface Iterator&lt;E&gt; &#123; /** * Returns &#123;@code true&#125; if the iteration has more elements. * (In other words, returns &#123;@code true&#125; if &#123;@link #next&#125; would * return an element rather than throwing an exception.) * 判断是否还有元素可以迭代 * @return &#123;@code true&#125; if the iteration has more elements */ boolean hasNext(); /** * Returns the next element in the iteration. * 返回下个元素 * @return the next element in the iteration * @throws NoSuchElementException if the iteration has no more elements */ E next(); /** * 移除元素 * Removes from the underlying collection the last element returned * by this iterator (optional operation). This method can be called * only once per call to &#123;@link #next&#125;. The behavior of an iterator * is unspecified if the underlying collection is modified while the * iteration is in progress in any way other than by calling this * method. * * @implSpec * The default implementation throws an instance of * &#123;@link UnsupportedOperationException&#125; and performs no other action. * * @throws UnsupportedOperationException if the &#123;@code remove&#125; * operation is not supported by this iterator * * @throws IllegalStateException if the &#123;@code next&#125; method has not * yet been called, or the &#123;@code remove&#125; method has already * been called after the last call to the &#123;@code next&#125; * method */ default void remove() &#123; throw new UnsupportedOperationException("remove"); &#125; /** * 这是Java 8为Iterator新增的默认方法，该方法可使用Lambda表达式来遍历集合 * Performs the given action for each remaining element until all elements * have been processed or the action throws an exception. Actions are * performed in the order of iteration, if that order is specified. * Exceptions thrown by the action are relayed to the caller. * * @implSpec * &lt;p&gt;The default implementation behaves as if: * &lt;pre&gt;&#123;@code * while (hasNext()) * action.accept(next()); * &#125;&lt;/pre&gt; * * @param action The action to be performed for each element * @throws NullPointerException if the specified action is null * @since 1.8 */ default void `forEachRemaining`(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; 一共四个方法，其中forEachRemaining是Java8新增的，通过使用Lambda表达式来遍历集合。剩下三个方法十分简洁。判断是否有下一个，有的话可以获取，以及移除元素。或许你会有疑惑，为什么这里没有添加元素的方法呢？我也不知道。留坑。不过我做一个猜想，是因为集合的结构。那么remove()是如何在不同集合中实现的呢？多态（好像是废话，其实这个部分应该放在具体的集合类中来写。比如ArrayList中iterator()是自身实现的，而LinkedList是父类AbstractSequentialList实现的）。为什么在使用foreach遍历过程，推荐使用迭代器中的remove()，而不是集合自身的remove()呢？首先，我们要明白移除元素的操作会改变集合大小。那么，在遍历过程中，如果不能及时的知道集合大小，那么肯定会引发错误。说到这里，应该就明白了。迭代器移除元素是不会引发这个错误的。那么是如何做到的呢？在实现remove()时，内部维护一个参数expectedModCount，这个参数和集合中代表修改次数的参数modCount有关。这个参数代表了当前集合的修改情况。在remove()时，自动同步这两个参数即可。但是如果遍历方式是普通for循环，而不是foreach，不会报错，但是不推荐，因为在移除一个元素之后，其它元素的位置发生变动，但是下标仍然是按之前的取，虽然运行时不会报错，但是逻辑上是错误的。使用foreach遍历，只是用来“看”。比如这段代码123456789ArrayList&lt;String&gt; a=new ArrayList&lt;String&gt;();a.add("1");a.add("2");a.add("3");for (int i = 0; i &lt; a.size();i++) &#123; a.remove(a.get(i));&#125;System.out.println("----------");System.out.println(a);//[2] 虽然是不会报错，但是结果输出为“[2]”。这是因为在遍历过程中，第一个元素被移除之后，a.size()变成2，剩余元素“2”，“3”的下标分别从“1”、“2”变成“0”、“1”。跳过了元素“2”。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2018%2F08%2F08%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[开坑]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap(一)]]></title>
    <url>%2F2018%2F08%2F08%2FHashMap%2F</url>
    <content type="text"><![CDATA[HashMap源码解析(一)HashMap是JavaSE中非常重要的的一个部分，加深对HashMap的理解，对学习Java有很大的帮助。这个系列的文章是我对HashMap的学习总结。在此做个记录。本文JDK为JDK1.8。 概述HashMap是Java常用的数据结构之一。首先来看看HashMap的继承关系123public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;&#125; 可以看出继承了AbstractMap&lt;K,V&gt;,实现了Map&lt;K,V&gt;方法。 结构在JDK1.8中主要是通过数组加单链表和红黑树实现HashMap。其中底层的数组被称为哈希桶，桶中存放链表或者树，每个节点代表每个元素。单链表和红黑树请查阅数据结构部分。图解HashMap的结构和工作原理(图源自网络)。 HashMap的创建方式主要有四种初始化方式。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; /** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; 可以看出这四种方式可以分别对初始容量和加载因子设置。说一下其中的tableSizeFor()和putMapEntries(m, false) 。 123456789101112/** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; 从注释中可以看出这个方法是返回大于输入参数且最近的2的整数次幂的数。这个方法对于提升性能效果很好。这里参考了这篇博文。https://blog.csdn.net/fan2012huan/article/details/51097331 采用按位或的方式 这个算法使得n的二进制的最高的1后面的位全部变成了1。那么为什么要先做cap-1操作呢？首先这是为了防止cap已经是2的幂的情况。如果没有-1操作，那么结果返回的是cap的double。然后经过几次无符号右移，使得最高位1后面全部变成1。最后加1。这个算法很聪明。123456789101112131415161718192021222324252627/** * Implements Map.putAll and Map constructor * * @param m the map * @param evict false when initially constructing this map, else * true (relayed to method afterNodeInsertion). */ final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); if (t &gt; threshold) threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; 其中的变量evict非常有意思，只有在构造方法使用map，调用putMapEntries()时，evict才为false。 主要的属性12345678910111213141516171819202122232425262728293031//创建HashMap时默认容量static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16//HashMap最大容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//默认加载因子static final float DEFAULT_LOAD_FACTOR = 0.75f;//链表转红黑树的阈值 /** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */static final int TREEIFY_THRESHOLD = 8;//红黑树转链表的阈值 /** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */static final int UNTREEIFY_THRESHOLD = 6;//存储方式由链表转红黑树的阈值static final int MIN_TREEIFY_CAPACITY = 64;//HashMap中存储的键值对的数量transient int size;//扩容阈值，当size&gt;=threshold时，就会扩容int threshold;//HashMap的加载因子 final float loadFactor; 为什么用1&lt;&lt;4的方式而不是直接用16？ 答：计算机底层是0和1。1&lt;&lt;4即把1向左位移4位，其余位置补零，就是10000，是二进制的16。与16转换成10000相比，效率更高。 为什么初始容量是16？ 答：内存对于计算机来说，是非常重要的资源。过大的容量是对资源的浪费，过小是对效率的折损。选择16，16是经验值，不会太大也不会太小。 什么是默认加载因子？为什么是0.75f？ 答：默认加载因子的作用主要是平衡“哈希冲突”和“空间利用率”。首先来说一下什么是“哈希冲突”。要知道什么是“哈希冲突”，先要明白什么是“哈希算法”。简单的说，在HashMap中，哈希算法的作用是给元素安排“座位”，哈希算法是对实现这种目的的方式的统称。HashMap中采用的是取模法（HashMap中的hash()非常有意思）。但是在“排座”的过程中，就会出现一个“重复”问题，不同元素的hash值（通过哈希算法得到的结果，在这里看成座位号）相同。这种情况的发生会随着元素的增加而变得频繁。这就是“哈希冲突”。那么什么是“空间利用率”呢？顾名思义，就是HashMap中实际元素数量和HashMap的容量的比值。那么现在来考虑一个问题。当“空间利用率”为1时，即元素填满了整个HashMap，那么从数据上来看，资源利用的非常好。但是之前说过，在容量一定时，元素越多，“哈希冲突”越频繁，这样带来的问题就是影响了效率。怎么办呢？通过设置一个值来确定一个兼顾哈希冲突和空间利用率，这样就能但是解决这个问题了。取0.75f是一个经验值，HashTable中的默认装载因子是1.0f。但是随之而来的是，当HashMap变得很大的时候，即使是剩余的0.25f，乘于容量之后也会很大，那么就造成了资源的浪费。怎么办呢？下次找到了答案再说。 什么是“TREEIFY_THRESHOLD”和“UNTREEIFY_THRESHOLD”？ 答：来看看源码注释是怎么解释的。“bin”在我理解是一个节点（Node）。就是说当桶中bin数量（在某个索引中链表的长度）超过8个时，存储结构转变城树；反之当少于6个时，转变为链表。但是注意，这里的转变结构是不可逆的，也就是说链表转变为树之后，再减少元素，仍然是树结构。之后在resize时，才可能从树转变为链表。 为什么是容量是2次幂? 答：下篇会写。]]></content>
      <categories>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Java重点</tag>
        <tag>树</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2018%2F08%2F07%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天是2018年8月7日，通过github和hexo搭建了自己第一个博客网站。由于hexo是静态页面，我通过hexo-admin来管理博客。然后手动commit。]]></content>
  </entry>
  <entry>
    <title><![CDATA[good good study,day day up.]]></title>
    <url>%2F2018%2F08%2F07%2Fhello-Hexo%2F</url>
    <content type="text"><![CDATA[数据结构+算法=程序]]></content>
  </entry>
</search>
